using System;
using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using XmlRpc.Serialization.Generators.Diagnostics;
using XmlRpc.Serialization.Generators.Extensions;
using XmlRpc.Serialization.Generators.Symbols;

namespace XmlRpc.Serialization.Generators;

[Generator]
internal class XmlRpcStructContextSourceGenerator : IIncrementalGenerator
{
  private const string ClassAttributeTypeName = "XmlRpc.Serialization.Attributes.XmlRpcStructSerializableAttribute";
  private const string ClassAttributeClassName = "XmlRpcStructSerializableAttribute";

  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    IncrementalValuesProvider<XmlRpcContextInfo?> classDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName<XmlRpcContextInfo?>(
        ClassAttributeTypeName,
        (node, _) => node is ClassDeclarationSyntax,
        (ctx, _) => GetSemanticTargetForGeneration(ctx))
      .Where(info => info is not null);

    IncrementalValueProvider<(Compilation, ImmutableArray<XmlRpcContextInfo?>)> compilation = context.CompilationProvider.Combine(classDeclarations.Collect());
    context.RegisterSourceOutput(compilation, (spc, source) => Execute(source.Item2!, spc));
  }

  private void Execute(ImmutableArray<XmlRpcContextInfo> contextClasses, SourceProductionContext productionContext)
  {
    foreach (XmlRpcContextInfo contextClass in contextClasses)
    {
      if (contextClass.SerializedType.Type.TypeKind != TypeKind.Class)
      {
        productionContext.ReportDiagnostic(Diagnostic.Create(DiagnosticConstants.InvalidConverterType, contextClass.Context.GetLocation(), contextClass.Context.Identifier.Text));
        return;
      }

      productionContext.AddSource(contextClass.GetGeneratedFileName(), GenerateContextClass(contextClass, productionContext));
    }
  }

  private static XmlRpcContextInfo? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context)
  {
    if (context.TargetNode is not ClassDeclarationSyntax classDeclaration)
    {
      return null;
    }

    AttributeData? attribute = context.Attributes.FirstOrDefault(a => a.AttributeClass?.Name == ClassAttributeClassName);
    if (attribute == null)
    {
      return null;
    }

    // [XmlRpcStructSerializable(Type type)]
    XmlRpcTypeInfo serializedType = new XmlRpcTypeInfo((INamedTypeSymbol)attribute.ConstructorArguments[0].Value!);

    return new XmlRpcContextInfo(classDeclaration, serializedType);
  }

  private static string GenerateContextClass(XmlRpcContextInfo contextInfo, SourceProductionContext productionContext)
  {
    using StringWriter stringWriter = new StringWriter();
    using IndentedTextWriter textWriter = new IndentedTextWriter(stringWriter, "  ");
    XmlRpcConverterGenerator converterGenerator = new XmlRpcConverterGenerator(textWriter, contextInfo, contextInfo.GetSerializedTypesFromProperties());

    textWriter.WriteLine("// <auto-generated/>");
    textWriter.WriteLine("using System;");
    textWriter.WriteLine("using XmlRpc.Serialization;");
    textWriter.WriteLine("using XmlRpc.Serialization.Converters;");
    textWriter.WriteLine();

    foreach (SyntaxNode syntaxNode in contextInfo.Parents)
    {
      switch (syntaxNode)
      {
        case BaseNamespaceDeclarationSyntax namespaceDecl:
          textWriter.BeginScope(namespaceDecl.GetDeclarationString());
          break;
        case TypeDeclarationSyntax typeDecl:
          textWriter.BeginScope(typeDecl.GetDeclarationString());
          break;
        default:
          productionContext.ReportDiagnostic(Diagnostic.Create(DiagnosticConstants.UnknownSyntaxNode, syntaxNode.GetLocation(), syntaxNode.GetType().ToString()));
          throw new Exception($"Unexpected SyntaxNode {contextInfo.GetType().Name}");
      }
    }

    textWriter.BeginScope(contextInfo.Context.GetDeclarationString());
    {
      converterGenerator.GenerateConverters("public");
    }
    textWriter.EndScope();

    for (int i = contextInfo.Parents.Count - 1; i >= 0; i--)
    {
      SyntaxNode syntaxNode = contextInfo.Parents[i];
      switch (syntaxNode)
      {
        case TypeDeclarationSyntax:
        case BaseNamespaceDeclarationSyntax:
          textWriter.EndScope();
          break;
        default:
          throw new Exception($"Unexpected SyntaxNode {contextInfo.GetType().Name}");
      }
    }

    return stringWriter.ToString();
  }
}
